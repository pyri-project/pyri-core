<p align="center">
<img src="./figures/pyri_logo_web.svg" height="200"/>
</p>

# Python Restricted Industrial (PyRI) Language Dialect Specification

*Version 0.1*

Last Updated: May 29, 2020

Dr. John Wason

Owner, Wason Technology, LLC
Visiting Researcher, Rensselaer Polytechnic Institute

## Introduction

Python is a popular and powerful scripting language. Its flexibility, ease of use, extensibility, and rich feature set have made it popular in engineering, computing, data science, and numerous other technical fields. While this flexibility is desirable in most use cases, it is not ideal for use in industrial robot programming. Automation technicians that program robots are often not trained in software development, and instead have a technical degree from a two year college. To help make robot programming easier, a subset of Python is defined that retains features necessary for this task, but eliminates features that only serve to add complexity and pitfalls for inexperienced developers. The restriction will also provide some level of protection against malicious users and cyber-attacks, although that is not the primary objective. **This document contains the specification for the Python Restricted Industrial (PyRI) Language Dialect.**

## Motivation

Python has gained significant popularity in robotics, and has become the de-facto standard for open-source development using ROS, Robot Raconteur, Orocos, and many other ecosystems. While Python has become popular within the open-source community for robot software development, most industrial applications still use propriety software languages such as ABB Rapid, Motoman INFORM, FANUC KAREL, Omron/Adept V+, Staubli VAL3, Kuka KRL, etc. These languages tend to be obscure, outdated, and limited when compared to newer scripting languages like Python or even JavaScript. Their obscurity and outdatedness makes acquiring, training, and retaining talent difficult and expensive. These languages also require some level of computer science knowledge to be properly utilized. The goal of the Python Restricted Industrial (PyRI) project is to create a simplified (restricted) Python dialect specifically for industrial automation/robotics programming that retains the desirable properties of Python, while presenting the technician with a friendly experience that is not overwhelmingly complicated. The PyRI project will also provide a runtime environment with sanddox, teach pendant hardware, user interface software, and plugins for use with the PyRI dialect. These components are discussed in other documents.

## Zope RestrictedPython Project

The concept of a restricted python sandbox is not new, and several examples exist including RPython from the PyPy project, MicroPython for embedded systems, and RestrictedPython from the Zope foundation. RestrictedPython is intended to allow untrusted web users to execute scripts on the server while preventing malicious behavior (aka "sandboxing"). [RestrictedPython describes their approach as:](https://restrictedpython.readthedocs.io/en/latest/idea.html)

> Defining a secure subset of the language involves restricting the EBNF elements and explicitly allowing or disallowing language features. Much of the power of a programming language derives from its standard and contributed libraries, so any calling of these methods must also be checked and potentially restricted. RestrictedPython generally disallows calls to any library that is not explicit whitelisted.

*(EBNF stands for "[Extended Backusâ€“Naur form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)", a metasyntax used to express context-free grammar)*

In practice, RestrictedPython module uses two approaches to create a secure sandbox environment:

1. Analyze the Abstract Syntax Tree (AST) generated by the Python compiler and remove potentially insecure operations, replacing with secure operations when necessary
2. Restrict access to built-in functions and modules to a secure subset, replacing insecure built-ins and modules with secure ones when necessary

The RestrictedPython module is customizable, meaning that it can be adapted for different uses beyond running web scripts. This flexibility means that the PyRI project can build on the RestrictedPython module and take advantage of their prior work. While the RestrictedPython module provides an excellent starting point for the PyRI language dialect and sandbox, the objectives are different. RestrictedPython assumes an experienced software developer and focuses on security, while PyRI assumes an inexperienced user and focuses on ease of use and reliability rather than security. (Security is still a significant concern for PyRI, but some level of trust needs to be placed in technicians to allow them to program expensive robots.) The rest of this document will discuss the default RestrictedPython configurations, and how they are modified for use with PyRI.

## Python Version

PyRI requires Python 3.6 or greater.  Interpreters other than CPython are not officially supported.

## Abstract Syntax Trees (AST)

Python scripts are compiled to bytecode where they are executed by the Python interpreter. The full procedure is discussed in detail in the [Python Developers Guide](https://devguide.python.org/compiler/). The Abstract Syntax Tree (AST) is an intermediate representation of the structure of the source code being compiled. More details on AST can be found on the [Wikipedia AST Page](https://en.wikipedia.org/wiki/Abstract_syntax_tree). The Python compiler uses the following steps to compile source code ([Python Developers Guide](https://devguide.python.org/compiler/):

> 1. Parse source code into a parse tree (Parser/pgen.c)
> 2. Transform parse tree into an Abstract Syntax Tree (Python/ast.c)
> 3. Transform AST into a Control Flow Graph (Python/compile.c)
> 4. Emit bytecode based on the Control Flow Graph (Python/compile.c)

RestrictedPython provides the special `compile_restricted()` function, which intercepts the compilation process between the generation of the AST (step 2) and creating the control flow graph (step 3). RestrictedPython uses "policies" to decide how to restrict and/or manipulate the AST. These policies are subclasses of `NodeTransformer`, a part of the Python standard library. (See [`ast.NodeTransform`](https://docs.python.org/3/library/ast.html#ast.NodeTransformer). The NodeTransformer class "walks" the AST tree. Subclasses override different methods to intercept nodes of the AST tree during the walk to modify or reject the AST. RestrictedPython provides the `RestrictedNodeTransformer` class, a subclass of `NodeTransformer` which provides a generic restricted policy, and is used by default. `RestrictedNodeTransformer` can be inherited to create a policy that modifies the default RestrictedPython policy. PyRI takes this approach, defining the `PyriRestrictedNodeTransformer` inheriting from RestrictedPython but customizing the policy.

Python compilation, AST generation, AST node types, AST transformation, and the security of Python are complicated subjects requiring significant background knowledge. Please refer to the following sources for more information on these background subjects:

* [Design of CPython's Compiler](https://devguide.python.org/compiler/)
* [Python Abstract Syntax Trees](https://docs.python.org/3/library/ast.html)
* [Green Tree Snakes - the missing Python AST docs](https://greentreesnakes.readthedocs.io/en/latest/)

The rest of this section will assume familiarity with these topics and for brevity will not expand on the definitions of these topics.

## AST Python Node Type Policies in RestrictedPython and PyRI

Each node in the AST represents an element in the Python code. The RestrictedPython policy needs to decide how to restrict each node. This section lists the possible node types (in Python 3.6 and greater). The policy action for RestrictedPython and PyRI are described. New or unknown node types are denied. See [Green Tree Snakes - the missing Python AST docs](https://greentreesnakes.readthedocs.io/en/latest/) for descriptions of each node and what they represent.

PyRI requires all elements to be within functions. The global scope is never executed.

### Literals

#### Constant

* RestrictedPython: Restricted
* PyRI: Restricted

Deny access to Ellipsis node

#### Num

*Deprecated since version 3.8: Replaced by `Constant`*

* RestrictedPython: Allowed
* PyRI: Allowed

#### Str

*Deprecated since version 3.8: Replaced by `Constant`*

* RestrictedPython: Allowed
* PyRI: Allowed

#### FormattedValue

* RestrictedPython: Allowed
* PyRI: Allowed

#### JoinedStr

* RestrictedPython: Allowed
* PyRI: Allowed

#### Bytes

*Deprecated since version 3.8: Replaced by `Constant`*

* RestrictedPython: Allowed
* PyRI: Allowed

#### List

* RestrictedPython: Allowed
* PyRI: Allowed

#### Tuple

* RestrictedPython: Allowed
* PyRI: Allowed

#### Set

* RestrictedPython: Allowed
* PyRI: Allowed

#### Dict

* RestrictedPython: Allowed
* PyRI: Allowed

#### Ellipsis

*Deprecated since version 3.8: Replaced by `Constant`*

* RestrictedPython: Denied
* PyRI: Denied

#### NameConstant

*Deprecated since version 3.8: Replaced by `Constant`*

* RestrictedPython: Allowed
* PyRI: Allowed

### Variables

#### Name

* RestrictedPython: Restricted
* **PyRI: Restricted**

RestrictedPython limits names in the following ways:

* "printed" and "print" functions are redirected to guarded versions of the functions
* Names must not start with "_" (protected and private functions)
* Names must not end with "\_\_roles\_\_"
* The names "print", "printed", "builtins", and "breakpoint" are restricted
* Certain special function names are allowed for class object operator overloads

PyRI names also must not end with an underscore.
RestrictedPython allowed names for operator overloads are denied in PyRI.

#### Load

* RestrictedPython: Allowed
* PyRI: Allowed

#### Store

* RestrictedPython: Allowed
* PyRI: Allowed

#### Del

* Restricted Python: Allowed
* PyRI: Allowed

#### Starred

* Restricted Python: Allowed
* **PyRI: Denied**

Starred operations introduce unnecessary complexity for PyRI.

### Expressions

#### Expr

* RestrictedPython: Allowed
* PyRI: Allowed

#### UnaryOp

* RestrictedPython: Allowed
* **PyRI: Restricted**

Operator overloads are not redirected by PyRI. To guard against unintentional use, the fence function
`_check_unary_op_allowed_()` is called on all arguments before the operator is used. The
guard function `_check_return_value_()` is used on the return value to check the return
from the function.

#### UAdd

* RestrictedPython: Allowed
* PyRI: Allowed

#### USub

* RestrictedPython: Allowed
* PyRI: Allowed

#### Not

* RestrictedPython: Allowed
* PyRI: Allowed

#### Invert

* RestrictedPython: Allowed
* PyRI: Allowed

#### BinOp

* RestrictedPython: Allowed
* **PyRI: Restricted**

Operator overloads are not redirected by PyRI. To guard against unintentional use, the fence function
`_check_binary_op_allowed_()` is called on all arguments before the operator is used. The
guard function `_check_return_value_()` is used on the return value to check the return
from the function.

#### Add

* RestrictedPython: Allowed
* PyRI: Allowed

#### Sub

* RestrictedPython: Allowed
* PyRI: Allowed

#### Mult

* RestrictedPython: Allowed
* PyRI: Allowed

#### Div

* RestrictedPython: Allowed
* PyRI: Allowed

#### FloorDiv

* RestrictedPython: Allowed
* PyRI: Allowed

#### Mod

* RestrictedPython: Allowed
* PyRI: Allowed

#### Pow

* RestrictedPython: Allowed
* PyRI: Allowed

#### LShift

* RestrictedPython: Allowed
* PyRI: Allowed

#### RShift

* RestrictedPython: Allowed
* PyRI: Allowed

#### BitOr

* RestrictedPython: Allowed
* PyRI: Allowed

#### BitXor

* RestrictedPython: Allowed
* PyRI: Allowed

#### BitAnd

* RestrictedPython: Allowed
* PyRI: Allowed

#### MatMult

* RestrictedPython: Denied
* **PyRI: Allowed**

#### BoolOp

* RestrictedPython: Allowed
* **PyRI: Restricted**

Operator overloads are not redirected by PyRI. To guard against unintentional use, the fence function
`_check_bool_op_allowed_()` is called on all arguments before the operator is used. The
guard function `_check_return_value_()` is used on the return value to check the return
from the function.

#### And

* RestrictedPython: Allowed
* PyRI: Allowed

#### Or

* RestrictedPython: Allowed
* PyRI: Allowed

#### Compare

* RestrictedPython: Allowed
* **PyRI: Restricted**

Operator overloads are not redirected by PyRI. To guard against unintentional use, the fence function
`_check_compare_allowed_()` is called on all arguments before the operator is used. The
guard function `_check_return_value_()` is used on the return value to check the return
from the function.

#### Eq

* RestrictedPython: Allowed
* PyRI: Allowed

#### NotEq

* RestrictedPython: Allowed
* PyRI: Allowed

#### Lt

* RestrictedPython: Allowed
* PyRI: Allowed

#### LtE

* RestrictedPython: Allowed
* PyRI: Allowed

#### Gt

* RestrictedPython: Allowed
* PyRI: Allowed

#### GtE

* RestrictedPython: Allowed
* PyRI: Allowed

#### Is

* RestrictedPython: Allowed
* PyRI: Allowed

#### IsNot

* RestrictedPython: Allowed
* PyRI: Allowed

#### In

* RestrictedPython: Allowed
* PyRI: Allowed

#### NotIn

* RestrictedPython: Allowed
* PyRI: Allowed

#### Call

* RestrictedPython: Restricted
* **PyRI: Restricted**

Prevent calls to "exec" and "eval" to protect against arbitrary code execution.

RestrictedPython protects unpacking of Starred argument tuples. Since the starred operator is denied in PyRI, this is unnecessary.

Disable use of **kwargs by denying kewyord nodes with arg=None

The name of the function being called is checked by the "Name" node.

PyRI allows for calling two special functions to track blockly execution:

* _begin_blockly_statement_
* _end_blockly_statement_

The guard function `_check_return_value_()` is used on the return value to check the return
from the function.

#### keyword

* RestrictedPython: Allowed
* PyRI: Allowed

#### IfExp

* RestrictedPython: Allowed
* PyRI: Allowed

#### Attribute

* RestrictedPython: Restricted
* **PyRI: Restricted**

Attribute access to objects is redirected to the guarded functions `_getattr_` and `_write_`.  Access to attributes starting with underscore "_" or ending with "\_\_roles\_\_" is denied. PyRI implements these guarded functions to protect data within plugin objects. PyRI also overrides the `Store` operation to use `_pyri_setattr_wrapper_`. This
guard is a small class that dispatches the `setattr` operation to the
correct PyRI object handler.

The guard function `_check_return_value_()` is used on the return value.

### Subscripting

#### Subscript

* RestrictedPython: Restricted
* **PyRI: Restricted**

RestrictedPython by default transforms subscript operations to use `_getitem_` and `_write_`. The docstring for this transformation is as follows (See [transformer.py](https://github.com/zopefoundation/RestrictedPython/blob/483353854f1e4b90f645f7fa1dc3352379a3f995/src/RestrictedPython/transformer.py#L946)):

    def visit_Subscript(self, node):
        """
        Transforms all kinds of subscripts.

        'foo[bar]' becomes '_getitem_(foo, bar)'
        'foo[:ab]' becomes '_getitem_(foo, slice(None, ab, None))'
        'foo[ab:]' becomes '_getitem_(foo, slice(ab, None, None))'
        'foo[a:b]' becomes '_getitem_(foo, slice(a, b, None))'
        'foo[a:b:c]' becomes '_getitem_(foo, slice(a, b, c))'
        'foo[a, b:c] becomes '_getitem_(foo, (a, slice(b, c, None)))'
        'foo[a] = c' becomes '_write_(foo)[a] = c'
        'del foo[a]' becomes 'del _write_(foo)[a]'

        The _write_ function should return a security proxy.
        """

        <function implementation>

PyRI uses these same `_getitem_` transformation, but uses a `_setitem_` transformation as instead of `_write_`. This redirects the set calls to PyRI specific functions. For `del` operations, this node will be transformed by `Delete` so is left unmodified.

The guard function `_check_return_value_()` is used on the return value.

#### Index

* RestrictedPython: Allowed
* PyRI: Allowed

#### Slice

* RestrictedPython: Allowed
* PyRI: Allowed

#### ExtSlice

* RestrictedPython: Allowed
* PyRI: Allowed

### Comprehensions

PyRI denies all comprehensions. Comprehensions operations introduce unnecessary complexity for PyRI.

#### ListComp

* RestrictedPython: Allowed
* **PyRI: Denied**

PyRI denies all comprehensions.

#### SetComp

* RestrictedPython: Allowed
* **PyRI: Denied**

PyRI denies all comprehensions.

#### GeneratorExp

* RestrictedPython: Allowed
* **PyRI: Denied**

PyRI denies all comprehensions.

#### DictComp

* RestrictedPython: Allowed
* **PyRI: Denied**

PyRI denies all comprehensions.

#### comprehension

* RestrictedPython: Allowed
* **PyRI: Denied**

PyRI denies all comprehensions.

### Statements

#### Assign

* RestrictedPython: Restricted
* **PyRI: Restricted**

RestrictedPython modifies assign operations to guard unpacking tuples using the `_getiter_` guard function. The name of the assigned variable is checked by the Name node.

PyRI adds more restrictions to assignments. Builtins and plugin objects must not be assigned. Also, module global scope variables must not be assigned. The global scope is never executed, so it must not be used.

Multiple assignment is disabled for simplicity.

The guard function `_check_assign_name_()` is used to prevent overwriting global variables.

#### AnnAssign

* RestrictedPython: Denied
* PyRI: Denied

#### AugAssign

* RestrictedPython: Restricted
* PyRI: **Denied**

AugAssign is not allowed in PyRI. It adds significant complexity to the interpreter, and most industial programming languages don't support it.

#### Raise

* RestrictedPython: Allowed
* PyRI: Allowed

#### Assert

* RestrictedPython: Allowed
* PyRI: Allowed

#### Delete

* RestrictedPython: Allowed
* **PyRI: Restricted**

Deleting variables adds complexity and is a potential pitfall for inexperienced users. Del is allowed for List, Tuple, Dict, and plugin objects, but is otherwise denied.

#### Pass

* RestrictedPython: Allowed
* PyRI: Allowed

### Imports

#### Import

* RestrictedPython: Restricted
* PyRI: Restricted

Check to prevent overwriting guard functions.

#### ImportFrom

* RestrictedPython: Restricted
* PyRI: Restricted

Check to prevent overwriting guard functions. Disallow "*" import.

#### alias

* RestrictedPython: Allowed
* PyRI: Allowed

### Control Flow

#### If

* RestrictedPython: Allowed
* PyRI: Allowed

#### For

* RestrictedPython: Allowed
* PyRI: **Restricted**

The guard function `_check_assign_name_()` is used to prevent overwriting global variables.

#### While

* RestrictedPython: Allowed
* PyRI: Allowed

#### Break

* RestrictedPython: Allowed
* PyRI: Allowed

#### Continue

* RestrictedPython: Allowed
* PyRI: Allowed

#### Try

* RestrictedPython: Allowed
* PyRI: **Restricted**

The guard function `_check_assign_name_()` is used to prevent overwriting global variables when catching exceptions.

#### With

* RestrictedPython: Restricted
* PyRI: **Restricted**

Tuple unpacking is guarded with `_getiter_` guard function. The guard function `_check_assign_name_()` is used to prevent overwriting global variables.

#### withitem

* RestrictedPython: Allowed
* PyRI: Allowed

### Function and class definitions

#### FunctionDef

* RestrictedPython: Restricted
* **PyRI: Restricted**

FunctionDef nodes are restricted in the following ways in RestrictedPython: Function name is checked, argument names are checked, print collector is injected, and tuple argument (star syntax) unpacking is protected. The name restrictions follow the same rules as the Name node. 

PyRI expands on the restrictions of RestrictedPython by preventing star notation for arguments, preventing redefining builtin or plugin object names, and preventing nested functions. Functions must be defined at the module level.

#### Lambda

* RestrictedPython: Restricted
* **PyRI: Denied**

Lambda functions introduce unnecessary complexity for PyRI.

#### arguments

* RestrictedPython: Allowed
* PyRI: Allowed

#### args

* RestrictedPython: Allowed
* **PyRI: Restricted**

Deny use of *args and **kwargs in function definitions to remove unnecessary complexity.

#### Return

* RestrictedPython: Allowed
* PyRI: Restricted

#### Yield

* RestrictedPython: Allowed
* **PyRI: Denied**

Generators introduce unnecessary complexity for PyRI.

#### YieldFrom

* RestrictedPython: Allowed
* **PyRI: Denied**

#### Global

* RestrictedPython: Allowed
* **PyRI: Denied**

PyRI has its own concept of "global" variables. PyRI redirects global variables to use the program global variable table.

#### Nonlocal

* RestrictedPython: Denied
* PyRI: Denied

#### ClassDef

* RestrictedPython: Restricted
* **PyRI: Denied**

Classes introduce unnecessary complexity for PyRI. Plugins are able to define classes that are made available for use in the PyRI sandbox.

### Async and await

* RestrictedPython: Denied
* PyRI: Denied

Async and await is denied in RestrictedPython and PyRI

#### AsyncFunctionDef

* RestrictedPython: Denied
* PyRI: Denied

#### Await

* RestrictedPython: Denied
* PyRI: Denied

#### AsyncFor

* RestrictedPython: Denied
* PyRI: Denied

#### AsyncWith

* RestrictedPython: Denied
* PyRI: Denied

### Top level nodes

#### Module

* RestrictedPython: Modified
* PyRI: Modified

"PrintCollector" is injected to capture print output instead of going to stdout.

#### Interactive

* RestrictedPython: Denied
* PyRI: Denied

#### Expression

* RestrictedPython: Allowed
* **PyRI: Denied**

PyRI is always compiled as a module.

## PyRI AST Node Policy Summary

The previous section defines the policy of each AST Node type. While precise, this does not provide much insight into how the behavior is affected. This section provides a human-readable list of how these policies restrict the Python language.

1. Names beginning or ending with underscores are protected, and cannot be read, written, or deleted. Exception is __begin_blockly_statement and __end_blockly_statement can be called to mark the execution progress of Blockly code.
2. The names "print", "printed", "builtins", and "breakpoint" are protected
3. `PrintCollector` is used to capture print statements instead of sending to `stdout`
4. The star operator for `*args` and `*kwargs` is denied
5. `eval` and `exec` are denied
6. Attributes are accessed using `_getattr_` and `_write_` guard functions. Attributes beginning with underscore "_" or ending with "\_\_roles\_\_" are denied.
7. Subscripting is redirected to use guard functions `_getitem_` and `_write_`
8. Comprehensions of all types are denied
9. Assignment is restricted. Bultins and plugin objects may not be overwritten. The guard function `_getiter_` is used for tuple expansion.
10. Annotation assignment is denied
11. Augmentation assignment is denied
12. Deletion is denied for variables, but allowed for sequence and plugin objects
13. Imports are restricted to a safe subset of the standard library and plugins
14. Exception handlers prevent overwriting builtins and plugin names, tuple expansion is protected with `_getiter_` guard function
15. With blocks prevent overwriting builtins and plugin names, tuple expansion is protected with `_getiter_`guard function
16. Function scope is restricted. Functions must be defined at the module level with valid names, must not begin or end with underscore
17. Inner functions and closures are denied
18. Lambda functions are denied
19. Yield, yield from, and generators are denied
20. Global is denied
21. Nonlocal is denied
22. Class and metaclass definitions are denied
23. Async, await, async for, and async with are denied
24. Expression and Interactive top level nodes are denied
25. Global module scope for all but functions is denied because module scope is never executed
26. Ellipsis (...) is denied
27. Accessing operators uses guard functions to prevent unintential use by the sandbox
28. Accessing attributes uses guards to protect classes that are not intended to be used by the sandbox
29. Objects can optionally redirect attribute calls to `_pyri_getattr_` and `_pyri_setattr_`

## Safe builtins and modules

### Safe builtins

RestrictedPython provides a set of [three builtin groups](https://restrictedpython.readthedocs.io/en/latest/usage/policy.html#predefined-builtins):

* `safe_builtins` a safe set of builtin modules and functions
* `limited_builtins` restricted sequence types
* `utility_builtins` access to standard modules like math, random, string, and set

The PyRI restricted Python dialect provides `safe_builtins` and `limited_builtins` for the user. The base sandbox has limited functionality, with all standard library and utility functions provided by plugins.

### Guard Functions

RestrictedPython modifies the AST to add "guard functions" to certain unsafe operations. These guard functions are designed to prevent unsafe behavior, or behavior that is confusing to novice users. PyRI modifies these guard functions to allow plugin objects to be accessed safely. See the plugin object section for more details.

## User-defined data types

The restricted Python dialect restricts the use of the `class` keyword. This prevents the definition of user-defined Python types. The reason for this restriction is to simplify the dialect for novice users, since Python class definitions can be complex and ambiguous at times. Python does not have a pure data structure type, meaning that any Python object contains both data and code (functions). Python objects also do not provide strong type checking. The restricted Python dialect requires user-defined pure data structure types that enforce strong data typing. These user-defined types are used within the restricted Python sandbox, and with the global variable table.

The user-defined structure types contain named "fields" of data, like most programming languages. It is implemented as a standard Python class, with `__getattr__` and `__setattr__` overridden to implement the user-defined fields, and also implement type checking to enforce the specified data types. The user defines these types using a type editor in the PyRI user interface, by modifying a YAML file directly, or specified in a plugin. Fields may have the following types:

* `int` (64 bit signed integer)
* `float` (64 bit floating point)
* `str` (unicode string)
* `list` (list or nested list)
* `dict` (dictionary)
* `struct` (user-defined structure)
* `object` (plugin object)
* `device` (device provided by a plugin)
* `signal` (signal provided by a plugin)

## Plugins

The PyRI architecture is designed around plugins. The core functionality is implemented to allow for programming of generic systems, with specialized functionality like robot motion programming implemented using plugins. This allows for greater customization of the architecture, and avoids overspecialization of the core system that can make future improvements difficult. Plugins provide a number of different features to the overall system. For the restricted Python dialect, the following are significant:

* Additional Python utility functions for use in the restricted Python sandbox.
* Plugin objects that can be accessed by the sandbox
* Devices that can be accessed by the sandbox
* User-defined data types
* Blockly block definitions

Plugins inject the functions, objects, devices, and types into the sandbox using the local and global tables passed to the `exec` function that executes the compiled sandbox code. Which functions and variables are injected into the sandbox is configured with a user interface, or with a YAML file that is associated with the sandbox software module. Helper functions are provided to access elements that were not directly injected, but this is not recommended.

Plugins must also provide a set of Blockly block definitions and validation routines that correspond to the Python functions, types, devices, and objects provided by the plugin. These block definitions also contain instructions on how to compile the block to Python for use in the sandbox. Plugins must be designed with consideration for Blockly use, since most users will most novice users will likely prefer Blockly over Python. Complex object-based or full object-oriented design should be avoided when possible, preferring simple, straightforward functional commands.
